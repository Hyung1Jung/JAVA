# 객체 생성과 파괴 (2장)

## 개요
- 이 책에서는 아래와 같이 개념을 정의한다.
- API를 사용하는 프로그램 작성자(사람)를 그 API의 사용자라고 한다.
- API를 사용하는 클래스(코드)는 그 API의 클라이언트라고 한다.

---

## Item1 : 생성자 대신 정정 팩토리 메서드(static factory method)를 고려하라. 
- public 생성자를 사용하여 객체를 생성하는 전통적인 방법 외에도 `static factory method`를 이용하여 객체(인스턴스)를 생성 할 수있다.
- `static factory method`의 장점과 단점을 알아보자.
 
### 장점 1 : 이름을 가질 수 있다.
- 생성자에 넘기는 매개변수와 생성자 자체만으로 반환될 객체의 특성을 제대로 설명하지 못한다.
    - 정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
- 하나의 시그니처로는 생성자를 하나만 만들 수 있다. 입력 매개변수들의 순서를 다르게 한 생성자를 새로 추가하는 식으로 이 제한을 피해볼 수도 있지만, 좋지 않은 발상이다.
    - 정적 팩터리 메서드는 이러한 제약이 없다. 한 클래스에 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주자.

### 장점 2 : 호출될 떄마다 인스턴스를 새로 생설하지 않아도 된다.
- 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다. 생성 비용이 큰 같은 객체가
자주 요청되는 상황이라면 성능을 상당히 끌어올려 준다.
- 반복되는 요청에 같은 객체를 반환하는 식으로 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철
저히 통제할 수 있다. 이런 클래스들을 통제클래스라 한다.이를 통해 클래스를 싱글톤으로 만들 수도, 인스턴스화가 불가능하게 만들 수도 있다. 또한 불변 값 클래스에서 동치인 인스턴스가
단하나뿐임을 보장할 수 있다.
- 인스턴스는 통제는 플라이웨이트 패턴의 근간이 되며, 열거 타입은 인스턴스가 하나만 만들어짐을 보장한다.  

### 장점 3 : 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
- 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 유연성을 가진다. 이 유연성은 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지
  할 수 있다. 이는 인터페이스 기반 프레임워크 (item 20) 를 만드는 핵심 기술이기도 하다.
- `java.util.Collections`가 대표적인 예시이며, 45개에 달하는 인터페이스의 구현체의 인스턴스를 제공하지만 그 구현체들은 전부 공개하지 않았다.
- 즉 프로그래머가 API를 사용하기 위해 익혀야하는 개념의 수와 난이도도 낮췄다. 명시한 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 굳이 별도로
문서를 찾아가며 실제 구현 클래스가 무엇인지 알아보지 않아도 된다.
- 나아가 정적 팩터리 메서드를 사용하는 클라이언트는 얻은 객체를 인터페이스만으로 다루개 된다.

### 장점 4 : 입력 매개변수에 따라 매번 다른 클래스의 개체를 반환할 수 있다.
- 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. 심지어 다음 릴리스에서는 또 다른 클래스의 객체를
반환해도 된다.
- `EnumSet` 클래스는 생성자 없이 public static 메서드, `allOf()`, `of()` 등을 제공한다.
- 그 내부에서는 enum 타입 원소의 갯수에 따라 `RegularEnumSet` 또는 `JumboEnumSet`으로 상황에 따라 다른 클래스의 객체를 반환한다.
- 클라이언트는 `EnumSet`이 넘겨주는 인스턴스가 어느 클래스의 인스턴스인지 알 필요가 없고 `EnumSet`의 하위 클래스 이기만 하면 된다.

### 장점 5 : 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
- 이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다.
- 대표적인 서비스 프로바이더 프레임워크로 `JDBC`가 있다.
- 서비스 프로바이더 프레임워크에서 `provider`는 서비스의 구현체다. 그리고 이 구현체들은 클라이언트에 제공하는 역할을 프레임워크가 
  통제하여 클라이언트를 구현체로부터 분리해준다.
- 서비스 프로바이더 프레임워크는 3개의 핵심 컴포넌트로 이루어진다.
    - 구현체의 동작을 정의하는 서비스 인터페이스(`service interface`)
    - 제공자가가 구현체를 등록할 때 사용하는 제공자 등록 API(aprovider registration API)
    - 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API(`serviece access API`)
- 클라이언트는 서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체들을 하나씩 
  돌아가며 반환한다.
- 이와 더불어 서비스 제공자 인터페이스라는 네 번째 컴포넌트가 쓰이기도 한다. 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명해준다. 
    - `JDBC`의 경우, `Connection`이 `서비스 인터페이스 역할`, `DriverManager.registerDriver()`가 `제공자 등록 API`. `DriverManager.getConnection()`이 `서비스 접근 API`. 그리고 `Driver`가 `서비스 제공자 인터페이스` 역할을 한다.
  
### 단점 1 : 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.
- 앞서 이야기한 컬렉션 프레임워크의 유틸리티 구현 클래스들은 상속할 수 없다는 이야기다.
- 어찌 보면 이 제약은 상속보다 컴포지션(아이템 18)을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있다.

### 단점 2 : 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 
- 생성자처럼 API 설명에 명확히 드러나지 않으니 사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야 한다.
- 메서드 이름을 널리 알려진 규약을 따라 짓는 식으로 문제를 완화해줘야한다.

### 정적 팩터리 메서드에서 흔히 사용하는 명명 방식들.
- from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
    - 예) Date d = Date.from(instant);
- of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반호나하는 집게 메서드
    = 예) Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
- valueOf : from과 of의 더 자세한 버전  
    - BigInterger prime = BigInteger.valueOf(Integer.MAX_VALUE);
- instance 혹은 getInstance (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만,같은 인스턴스임을 보장하지는 않는다.
    - 예) StackWalker luke = StackWalker.getInstance(options);
- create 혹은 newInstance : instance 혹은 getInstance와 같지만, 배번 새로운 인스턴스를 생성해 반환함을 보장한다.
    - 예) Object newArray = Array.newInstance(classObject, arrayLen);
- getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가
반환할 객체의 타입이다.
    - 예) FileStore fs = Files.getFileStore(path)  
- newType : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. "Type"은 팩터리 메서드가
반환할 객체의 타입이다.
    - 예) BufferReader br = Files.newBufferedReader(path);
- type : getType과 newType의 간결한 버전
    - 예) List<Complaint> litany = Collections.list(legacyLitany);
    
### 핵심 정리
- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋다. 
